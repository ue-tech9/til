

####################################################

コンテナのUID,GID バインドマウント

####################################################
コンテナのログについて調査
MONTH="2020-08"
START="${MONTH}-01T00:00:00"
END="$(date -d "${MONTH}-01 +1 month" +%Y-%m-01)T00:00:00"

BASE="/var/log/jupyterhub-xxxxxx"
OUTDIR="${BASE}/exports"
mkdir -p "$OUTDIR"

cat ${BASE}/dockerlogs/jupyterhub-offline_*.log 2>/dev/null \
| awk -v start="$START" -v end="$END" '
  {
    ts=$1
    sub(/\.[0-9]+Z$/, "Z", ts)
    if (ts >= start && ts < end) print
  }
' > "${OUTDIR}/dockerlogs_full_${MONTH}.log"

grep -Ei "Server .* is ready" "${OUTDIR}/dockerlogs_full_${MONTH}.log" \
  > "${OUTDIR}/dockerlogs_ready_${MONTH}.log"





どうやって “古い” を判別してる？
-mtime +90 の意味

mtime = 最終更新日時（最後に内容が書き換わった時刻）

-mtime +90 = “最終更新が90日より前” のファイルを対象にする

つまり、

今日が 2025-12-22 だとしたら

ざっくり 2025-09-23 より前に最後に更新された .log が「古い」と判定されるイメージ。

※ find の日数は「24時間単位」で数えるので、境界はきっちり日付ジャストではなく“約”になることがある。

find "${LOG_BASE}" \
  -type f \
  -name "*.log" \
  -mtime +${LOG_RETENTION_DAYS} \
  -delete \
  2>/dev/null || true

find "${LOG_BASE}"
→ ./logs 配下を探す

-type f
→ ファイルだけ（ディレクトリは除外）

-name "*.log"
→ 拡張子 .log だけ

-mtime +90
→ 最終更新が90日より前

-delete
→ 見つかったものを削除

2>/dev/null
→ エラー表示を捨てる（権限エラー等）

|| true
→ 何か失敗してもスクリプト全体は止めない




####################################################
STS方式で、OSユーザをセッション情報に刻印できるか

####################################################
Nginx導入について
ダウンロード機能　ファイル送信


####################################################
Jupyterでの権限変更

TARGET="."
echo "Target (PWD) = $(pwd)"

# 直下だけ（. 自体は除外したいので -mindepth 1）
find "$TARGET" -maxdepth 1 -mindepth 1 -type d -exec chmod 2775 {} +
find "$TARGET" -maxdepth 1 -mindepth 1 -type f -exec chmod 664 {} +

echo "done"

# ============================================
# 目的:
#   「今いるフォルダ(PWD)の直下」だけを対象に権限を整える
#   - サブディレクトリの中身には入らない（再帰しない）
#   - 直下の "フォルダ" は 2775
#   - 直下の "ファイル" は 664
# ============================================

# 対象フォルダを変数に入れる
# "." は「カレントディレクトリ（今いる場所）」の意味
TARGET="."

# いまどこを対象にしているか表示（事故防止の確認用）
# pwd は「現在のディレクトリのパス」を表示するコマンド
echo "Target (PWD) = $(pwd)"

# -----------------------------
# 直下の「ディレクトリ（フォルダ）」だけを2775にする
# -----------------------------
# find "$TARGET"                    : 対象フォルダ配下を検索
# -maxdepth 1                       : 深さ1まで（直下だけ）。サブフォルダの中には入らない
# -mindepth 1                       : 深さ0（= TARGET自身 "."）を除外し、直下の項目だけ対象
# -type d                           : ディレクトリだけ対象（d = directory）
# -exec chmod 2775 {} +             : 見つかったディレクトリ全部に chmod 2775 を実行
find "$TARGET" -maxdepth 1 -mindepth 1 -type d -exec chmod 2775 {} +

# -----------------------------
# 直下の「ファイル」だけを664にする（Excel, ipynb も全部ファイル扱い）
# -----------------------------
# -type f                           : ファイルだけ対象（f = file）
# -exec chmod 664 {} +              : 見つかったファイル全部に chmod 664 を実行
find "$TARGET" -maxdepth 1 -mindepth 1 -type f -exec chmod 664 {} +

# 完了メッセージ
echo "done"

# --------------------------------------------
# 参考:
# 2775 (ディレクトリ用) = rwxrwsr-x
#   - 所有者: rwx（読/書/入れる）
#   - グループ: rwx（読/書/入れる）
#   - その他: r-x（読む/入れる、書けない）
#   - 先頭の「2」は setgid。配下で作られるファイルが同じグループになりやすい
#
# 664 (ファイル用) = rw-rw-r--
#   - 所有者: rw（読/書）
#   - グループ: rw（読/書）←他の人が編集できるようにするポイント
#   - その他: r-（読むだけ）
# --------------------------------------------


####################################################

# 特殊権限（special bits）はこの3つ
# 4 = setuid  (SUID)
# 2 = setgid  (SGID)
# 1 = sticky  (スティッキービット)
#
# 先頭の桁は、これらを足し算した値になる
# 例：2 なら SGIDのみ、3 なら SGID(2)+sticky(1)、6 なら SUID(4)+SGID(2)

# 4 = setuid
#  - 主に「実行ファイル」に付ける
#  - 実行したユーザーではなく「ファイル所有者の権限」で動く
#  - 例: /usr/bin/passwd など（一般ユーザーがパスワード変更できる仕組み）
# 「4」が付くと何が起きる？
# ---------------------------------
# これは基本的に “実行ファイル（コマンド）” に付けるもの。
#
# 普通の実行ファイルは：
#   実行したユーザーの権限で動く
#
# setuid(4) が付いた実行ファイルは：
#   実行した人ではなく「そのファイルの所有者(owner)の権限」で動く
#
# 例（有名）:
#   /usr/bin/passwd は一般ユーザーでもパスワード変更できる
#   でも /etc/shadow は root しか書けない
#   → passwd コマンドが root 権限で必要な処理を代行するために SUID が使われることがある
# ---------------------------------------------------------
# 「4」は ls -l でどう見える？
# ---------------------------------------------------------
# 例：所有者の実行権(x)の位置が s になる
#   -rwsr-xr-x  1 root root ... /usr/bin/passwd
#     ^ ここが s
#
# この "s" が「SUID が付いてるよ」の印。

# 2 = setgid
#  - 実行ファイル: 「ファイルのグループ権限」で動く
#  - ディレクトリ: 配下で作られるファイル/フォルダの "group" を揃えやすい（今回これ）

# 1 = sticky
#  - 主に「ディレクトリ」に付ける
#  - 誰でも書き込める共有ディレクトリでも
#    「削除できるのは所有者（かroot）だけ」にできる
#  - 例: /tmp は sticky が付いてることが多い





####################################################




####################################################


####################################################



####################################################




####################################################
