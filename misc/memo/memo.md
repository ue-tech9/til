

####################################################

コンテナのUID,GID バインドマウント

https://docs.docker.com/engine/storage/volumes/

https://docs.docker.com/engine/storage/bind-mounts/

考慮事項と制約
バインドマウントは、デフォルトでホスト上のファイルへの書き込みアクセス権を持ちます。

バインドマウントを使用することで、コンテナ内で実行されているプロセスを介してホストファイルシステムを変更できるという副作用が生じます。これには、重要なシステムファイルやディレクトリの作成、変更、削除などが含まれます。この機能はセキュリティに影響を与える可能性があります。例えば、ホストシステム上のDocker以外のプロセスに影響を与える可能性があります。



# =========================================================
# マウントとは？
# =========================================================
# 「ある場所にあるデータ（ストレージ/ディレクトリ）を、別のパスとして見せる」仕組み。
# コンテナでは大きく 2種類をよく使う：
#   1) バインドマウント（Bind mount）
#   2) ボリュームマウント（Named volume / Docker volume）※ここでは「普通のマウント」として扱う
#
# ※ “tmpfs” というメモリ上マウントもあるが、今回は割愛
#
# =========================================================
# 1) バインドマウント（Bind mount）
# =========================================================
# ホスト（EC2など）の「特定パス」を、そのままコンテナ内のパスに差し込む方式。
# 例: docker run -v /host/path:/container/path
#
# 特徴:
# - 実体はホストのファイルシステム
# - コンテナから見る所有者/権限（UID/GID/mode）は “ホスト実体の属性” が反映される
# - ホスト側のファイルを編集すると、コンテナにも即反映される（同一実体）
#
# 主な用途:
# - 設定ファイルの差し替え（イメージ再ビルド不要）
# - ホストに残したいデータ永続化（ログ、成果物、ユーザーデータなど）
# - オフライン資材や成果物の受け渡し（ホストが搬送役になる）
#
# 注意点（権限）:
# - 権限はホストが支配するため、UID/GIDがズレると Permission denied が起きやすい
# - コンテナ内で chown/chmod をすると “ホスト実体が変更される” ので要注意
#
# 使い方のコツ:
# - 読むだけのものは :ro を付ける（改ざん/事故防止）
#   例: -v ./config.yml:/app/config.yml:ro
#
# =========================================================
# 2) ボリュームマウント（Named volume / Docker volume）＝ “普通のマウント”
# =========================================================
# Docker が管理する領域（/var/lib/docker/volumes/...）にデータを置き、
# それをコンテナにマウントする方式。
# 例:
#   docker volume create mydata
#   docker run -v mydata:/app/data ...
#
# 特徴:
# - 実体の保存場所は Docker が管理（ホスト上の特定ディレクトリを直接触らない運用が多い）
# - コンテナ削除しても、ボリュームを消さない限りデータは残る（永続化）
# - バインドマウントより “ポータブル/運用しやすい” ケースが多い
# - Docker の仕組みに沿ってバックアップ/移行がしやすい（volume単位で扱える）
#
# 主な用途:
# - DBデータなど「アプリが内部で管理する永続データ」
# - ホストの任意パスに依存したくない（環境差を減らしたい）
# - Compose/ECS等の運用で “データ領域” を素直に切り出したい
#
# 注意点:
# - ホスト側で中身を直接見たり編集したりは、バインドマウントより一手間（基本は docker 経由）
# - 権限問題は依然あり得る（ただし “ホスト任意パス” に依存しない分、整理しやすい）
#
# =========================================================
# Bind mount と Volume mount の違い（ざっくり比較）
# =========================================================
# 目的/観点            | バインドマウント                 | ボリュームマウント（普通）
# ---------------------|----------------------------------|-----------------------------
# 実体の場所           | ホストの指定パス                 | Docker管理領域
# ホストからの編集     | しやすい（そのまま触れる）       | 直接はしにくい（docker経由が基本）
# 環境依存             | 高め（ホストのパス構造に依存）   | 低め（volume名で抽象化）
# 永続化               | できる                           | できる
# 移行/バックアップ     | 自力運用（rsync等）しやすい      | dockerの仕組みで扱いやすい
# 権限（UID/GID）       | ホスト属性が強く効く             | 依然注意（ただし整理しやすいことが多い）
#
# =========================================================
# それぞれの使い分け（用途別おすすめ）
# =========================================================
# バインドマウントが向く:
# - “ホスト側で管理したい/編集したい” ファイル（設定、鍵、証明書、スクリプト）
# - ログをホストに確実に残したい
# - オフライン資材の投入など、ホストとコンテナで受け渡ししたい
#
# ボリュームマウントが向く:
# - DBやアプリ内部データなど、コンテナ運用の中で素直に永続化したい
# - パス依存を減らして環境差を小さくしたい（移植性重視）
# - Compose/ECS等で標準的に “データ領域” を切り出したい
#
# =========================================================
# 権限を “ホストに合わせてゲストも同じ感じ” にする基本戦略（汎用）
# =========================================================
# バインドマウント/ボリュームマウントどちらでも、最終的に重要なのは：
#   「コンテナ内プロセスが、マウント先に対して正しいUID/GIDで動くこと」
#
# よく使う方法:
# - 方法A: 実行ユーザーを合わせる（シンプル）
#   docker run --user <uid>:<gid> -v ...  （名前より数字を優先する運用）
#
# - 方法B: 起動時にユーザー/グループを作って合わせる（整った運用）
#   対象ディレクトリの uid/gid/mode を取得 → コンテナ内に user/group を作成 → 一致させる
#
# 安全のコツ:
# - 不一致があるときは “自動修正” より “検知して停止（Fail Fast）” が事故りにくい
# - 読み取り専用でよいものは :ro を付ける
#
# =========================================================
# まとめ
# =========================================================
# - バインドマウント: ホストのパスを直接差し込む（編集しやすい・パス依存あり）
# - ボリュームマウント: Docker管理の永続領域を使う（移植性・運用性が高い）
# - どちらも権限（UID/GID/mode）が重要で、実行ユーザーを揃える設計が安定


####################################################
コンテナのログについて調査
https://docs.docker.com/engine/logging/configure


MONTH="2020-08"
START="${MONTH}-01T00:00:00"
END="$(date -d "${MONTH}-01 +1 month" +%Y-%m-01)T00:00:00"

BASE="/var/log/jupyterhub-xxxxxx"
OUTDIR="${BASE}/exports"
mkdir -p "$OUTDIR"

cat ${BASE}/dockerlogs/jupyterhub-offline_*.log 2>/dev/null \
| awk -v start="$START" -v end="$END" '
  {
    ts=$1
    sub(/\.[0-9]+Z$/, "Z", ts)
    if (ts >= start && ts < end) print
  }
' > "${OUTDIR}/dockerlogs_full_${MONTH}.log"

grep -Ei "Server .* is ready" "${OUTDIR}/dockerlogs_full_${MONTH}.log" \
  > "${OUTDIR}/dockerlogs_ready_${MONTH}.log"





どうやって “古い” を判別してる？
-mtime +90 の意味

mtime = 最終更新日時（最後に内容が書き換わった時刻）

-mtime +90 = “最終更新が90日より前” のファイルを対象にする

つまり、

今日が 2025-12-22 だとしたら

ざっくり 2025-09-23 より前に最後に更新された .log が「古い」と判定されるイメージ。

※ find の日数は「24時間単位」で数えるので、境界はきっちり日付ジャストではなく“約”になることがある。

find "${LOG_BASE}" \
  -type f \
  -name "*.log" \
  -mtime +${LOG_RETENTION_DAYS} \
  -delete \
  2>/dev/null || true

find "${LOG_BASE}"
→ ./logs 配下を探す

-type f
→ ファイルだけ（ディレクトリは除外）

-name "*.log"
→ 拡張子 .log だけ

-mtime +90
→ 最終更新が90日より前

-delete
→ 見つかったものを削除

2>/dev/null
→ エラー表示を捨てる（権限エラー等）

|| true
→ 何か失敗してもスクリプト全体は止めない

####################################################

Docker の json-file ログを サイズ＋世代数で回す設定

# =========================================================
# Docker(json-file) ログローテ設定（サイズ＋世代数）
# =========================================================
# 目的:
# - /var/lib/docker/containers/.../*-json.log の肥大化防止
# - ルートボリューム枯渇（EC2ごと死ぬ）を防ぐ
#
# 仕組み:
# - max-size を超えるとローテ（ファイル切り替え）
# - max-file の世代数だけ保持（超えたら古いものから削除）
#
# 例:
# - max-size=50m, max-file=10 → 1コンテナあたり最大約500MBまで
#   (厳密には多少前後するが、上限目安として十分使える)
#
# 注意:
# - 既に起動しているコンテナには “即時反映” されないことがある
#   → 基本は docker 再起動後にコンテナも再起動すると確実
# =========================================================

# 1) 現状ログドライバ確認（json-file なら今回の対象）
docker info | grep -i "Logging Driver"

# 2) 設定ファイル作成/更新
sudo mkdir -p /etc/docker

sudo tee /etc/docker/daemon.json > /dev/null <<'EOF'
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "50m",
    "max-file": "10"
  }
}
EOF

# 3) 反映（Dockerデーモン再起動）
sudo systemctl restart docker

# 4) 反映確認（対象コンテナで確認）
# ※ <container> は実在のコンテナ名/IDに置換
docker inspect --format='{{.HostConfig.LogConfig.Type}} {{json .HostConfig.LogConfig.Config}}' <container>

# 5) 肥大化の確認（上位を眺める）
sudo du -h /var/lib/docker/containers/*/*-json.log 2>/dev/null | sort -h | tail -n 20





####################################################
STS方式で、OSユーザをセッション情報に刻印できるか

####################################################
Nginx導入について
ダウンロード機能　ファイル送信


####################################################
Jupyterでの権限変更

TARGET="."
echo "Target (PWD) = $(pwd)"

# 直下だけ（. 自体は除外したいので -mindepth 1）
find "$TARGET" -maxdepth 1 -mindepth 1 -type d -exec chmod 2775 {} +
find "$TARGET" -maxdepth 1 -mindepth 1 -type f -exec chmod 664 {} +

echo "done"

# ============================================
# 目的:
#   「今いるフォルダ(PWD)の直下」だけを対象に権限を整える
#   - サブディレクトリの中身には入らない（再帰しない）
#   - 直下の "フォルダ" は 2775
#   - 直下の "ファイル" は 664
# ============================================

# 対象フォルダを変数に入れる
# "." は「カレントディレクトリ（今いる場所）」の意味
TARGET="."

# いまどこを対象にしているか表示（事故防止の確認用）
# pwd は「現在のディレクトリのパス」を表示するコマンド
echo "Target (PWD) = $(pwd)"

# -----------------------------
# 直下の「ディレクトリ（フォルダ）」だけを2775にする
# -----------------------------
# find "$TARGET"                    : 対象フォルダ配下を検索
# -maxdepth 1                       : 深さ1まで（直下だけ）。サブフォルダの中には入らない
# -mindepth 1                       : 深さ0（= TARGET自身 "."）を除外し、直下の項目だけ対象
# -type d                           : ディレクトリだけ対象（d = directory）
# -exec chmod 2775 {} +             : 見つかったディレクトリ全部に chmod 2775 を実行
find "$TARGET" -maxdepth 1 -mindepth 1 -type d -exec chmod 2775 {} +

# -----------------------------
# 直下の「ファイル」だけを664にする（Excel, ipynb も全部ファイル扱い）
# -----------------------------
# -type f                           : ファイルだけ対象（f = file）
# -exec chmod 664 {} +              : 見つかったファイル全部に chmod 664 を実行
find "$TARGET" -maxdepth 1 -mindepth 1 -type f -exec chmod 664 {} +

# 完了メッセージ
echo "done"

# --------------------------------------------
# 参考:
# 2775 (ディレクトリ用) = rwxrwsr-x
#   - 所有者: rwx（読/書/入れる）
#   - グループ: rwx（読/書/入れる）
#   - その他: r-x（読む/入れる、書けない）
#   - 先頭の「2」は setgid。配下で作られるファイルが同じグループになりやすい
#
# 664 (ファイル用) = rw-rw-r--
#   - 所有者: rw（読/書）
#   - グループ: rw（読/書）←他の人が編集できるようにするポイント
#   - その他: r-（読むだけ）
# --------------------------------------------


####################################################

# 特殊権限（special bits）はこの3つ
# 4 = setuid  (SUID)
# 2 = setgid  (SGID)
# 1 = sticky  (スティッキービット)
#
# 先頭の桁は、これらを足し算した値になる
# 例：2 なら SGIDのみ、3 なら SGID(2)+sticky(1)、6 なら SUID(4)+SGID(2)

# 4 = setuid
#  - 主に「実行ファイル」に付ける
#  - 実行したユーザーではなく「ファイル所有者の権限」で動く
#  - 例: /usr/bin/passwd など（一般ユーザーがパスワード変更できる仕組み）
# 「4」が付くと何が起きる？
# ---------------------------------
# これは基本的に “実行ファイル（コマンド）” に付けるもの。
#
# 普通の実行ファイルは：
#   実行したユーザーの権限で動く
#
# setuid(4) が付いた実行ファイルは：
#   実行した人ではなく「そのファイルの所有者(owner)の権限」で動く
#
# 例（有名）:
#   /usr/bin/passwd は一般ユーザーでもパスワード変更できる
#   でも /etc/shadow は root しか書けない
#   → passwd コマンドが root 権限で必要な処理を代行するために SUID が使われることがある
# ---------------------------------------------------------
# 「4」は ls -l でどう見える？
# ---------------------------------------------------------
# 例：所有者の実行権(x)の位置が s になる
#   -rwsr-xr-x  1 root root ... /usr/bin/passwd
#     ^ ここが s
#
# この "s" が「SUID が付いてるよ」の印。

# 2 = setgid
#  - 実行ファイル: 「ファイルのグループ権限」で動く
#  - ディレクトリ: 配下で作られるファイル/フォルダの "group" を揃えやすい（今回これ）

# 1 = sticky
#  - 主に「ディレクトリ」に付ける
#  - 誰でも書き込める共有ディレクトリでも
#    「削除できるのは所有者（かroot）だけ」にできる
#  - 例: /tmp は sticky が付いてることが多い





####################################################

Pam ケロベロス

セキュリティグループ（まずは「認証だけ」最低限）

Linux（PAM/Kerberos）からDCに向けて、最低限これが通れば “kinit系” は進みやすい：

TCP/UDP 88（Kerberos）

TCP/UDP 53（DNS）

（必要に応じて）TCP/UDP 464（kpasswd等）




####################################################


####################################################



####################################################




####################################################
